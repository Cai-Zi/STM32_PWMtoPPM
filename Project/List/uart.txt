; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I.\RTE\_TimeCounter -Id:\Keil_v5\MDK\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -Id:\Keil_v5\MDK\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\uart.crf ..\BaseDrive\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;3      
;;;4      void uart_init(void)
000000  b500              PUSH     {lr}
;;;5      {
000002  b085              SUB      sp,sp,#0x14
;;;6          USART_InitTypeDef USART_InitStructure;
;;;7          GPIO_InitTypeDef GPIO_InitStructure;
;;;8      
;;;9          RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0388              LSLS     r0,r1,#14
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;10         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2004              MOVS     r0,#4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;11         
;;;12         // TX
;;;13         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0000          STRH     r0,[sp,#0]
;;;14         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;15         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0003          STRB     r0,[sp,#3]
;;;16         GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  4669              MOV      r1,sp
00002a  481d              LDR      r0,|L1.160|
00002c  f7fffffe          BL       GPIO_Init
;;;17         
;;;18         // RX
;;;19         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0000          STRH     r0,[sp,#0]
;;;20         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000038  2003              MOVS     r0,#3
00003a  f88d0002          STRB     r0,[sp,#2]
;;;21         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003e  2004              MOVS     r0,#4
000040  f88d0003          STRB     r0,[sp,#3]
;;;22         GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  4669              MOV      r1,sp
000046  4816              LDR      r0,|L1.160|
000048  f7fffffe          BL       GPIO_Init
;;;23     
;;;24         USART_InitStructure.USART_BaudRate = 115200;
00004c  f44f30e1          MOV      r0,#0x1c200
000050  9001              STR      r0,[sp,#4]
;;;25         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000052  2000              MOVS     r0,#0
000054  f8ad0008          STRH     r0,[sp,#8]
;;;26         USART_InitStructure.USART_StopBits = USART_StopBits_1;
000058  f8ad000a          STRH     r0,[sp,#0xa]
;;;27         USART_InitStructure.USART_Parity = USART_Parity_No;
00005c  f8ad000c          STRH     r0,[sp,#0xc]
;;;28         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000060  f8ad0010          STRH     r0,[sp,#0x10]
;;;29         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000064  200c              MOVS     r0,#0xc
000066  f8ad000e          STRH     r0,[sp,#0xe]
;;;30     
;;;31         USART_Init(USART1, &USART_InitStructure);
00006a  a901              ADD      r1,sp,#4
00006c  480d              LDR      r0,|L1.164|
00006e  f7fffffe          BL       USART_Init
;;;32         /* Enable USART1 */
;;;33         USART_Cmd(USART1, ENABLE);
000072  2101              MOVS     r1,#1
000074  480b              LDR      r0,|L1.164|
000076  f7fffffe          BL       USART_Cmd
;;;34     }
00007a  b005              ADD      sp,sp,#0x14
00007c  bd00              POP      {pc}
;;;35     
                          ENDP

                  fputc PROC
;;;38     */
;;;39     int fputc(int ch, FILE *f)
00007e  b570              PUSH     {r4-r6,lr}
;;;40     {
000080  4604              MOV      r4,r0
000082  460d              MOV      r5,r1
;;;41     	/* Place your implementation of fputc here */
;;;42     	/* e.g. write a character to the USART */
;;;43     	USART_SendData(USART1, (uint8_t) ch);
000084  b2e1              UXTB     r1,r4
000086  4807              LDR      r0,|L1.164|
000088  f7fffffe          BL       USART_SendData
;;;44     
;;;45     	/* Loop until the end of transmission */
;;;46     	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
00008c  bf00              NOP      
                  |L1.142|
00008e  2180              MOVS     r1,#0x80
000090  4804              LDR      r0,|L1.164|
000092  f7fffffe          BL       USART_GetFlagStatus
000096  2800              CMP      r0,#0
000098  d0f9              BEQ      |L1.142|
;;;47     	return ch;
00009a  4620              MOV      r0,r4
;;;48     }
00009c  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP

00009e  0000              DCW      0x0000
                  |L1.160|
                          DCD      0x40010800
                  |L1.164|
                          DCD      0x40013800
